# -*- coding: utf-8 -*-
"""day13_function_mutability_and_varargs.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1v6_bSLYh_gUWAVrMU-VJf-DX24TMy8ga
"""

"""Preventing a function from modifying a list"""
#lets test the mutability of lists in functions
def mutate(listy):
  i = 0
  while i < len (listy): #I have to focus on this iterator.I always get this wrong
    listy[i] = listy[i] * 2
    i += 1
  #print(f"I am in the function. The list values are : {listy}")
  return listy

listed = [1,2,3,4,5]
print (f"list value before mutate {listed}")
mutate(listed)
print(f"print value after mutate {listed}")
#conclusion: the values in the list are changed in the functions. Effectively the list and the parameter
#in the function refer to the same location.
#I will try with tuples

tupley = (1,2,3,4,5)
print (f"tuple value before mutate {tupley}")
mutate(list(tupley))
print(f"print value after mutate {tupley}")
##Tuples are not mutable

###Let's explpore shallow copy in the list

def mutate_shadow(list_1):
  print("I am testing the shallow copy")
  list_2 = [x**2 for x in list_1]
  list_1 = list_2
  print(f"I am in the function. The list values are : {list_1}")
  return list_1

listed = [1,2,3,4,5]
print (f"list value before mutate_shadow {listed}")
mutate_shadow(listed[:]) #The listed value could not be manipulated.There will be a differnt mapping to the memory location
print(f"print value after mutate_shadow {listed}")

#Send as many arguments as one can

print ("testing unlimited parameters")
def unlimited_param(*myparams):
  print(f"This call has {len(myparams)}")
  for param in myparams:
    print(param)

unlimited_param(1) #passing just one param
unlimited_param(10,20,30,40,50) #passing many params
unlimited_param() #No params
my_para_list = [1,3,5,7]
unlimited_param(my_para_list) #passing a list as a parameter
#Tomorrow need test the nature of the unlimited paramters meaning data type

